# Docker

`Images`: os file (somewhat like ISO file in VM)

`Container`: Run time instance of image

## Basic Commands

### List of running container

```
docker ps
docker container ls
```

`ps` stands for processes

### List of running and stopped containers

```
docker ps -a
docker container ls -a
```

### List of images

```
docker images
```

### Adhoc Running

```
docker run -it <image name>
docker run -it ubuntu
docker run -it --name asd_1 ubuntu
```

- run creates new container everytime
- `-it` opens command line in iteractive(`-i`) pseudo-TTY(`-t`) (connects your terminal with container terminal)
- Docker containers typically run as the root user by default
- Container is started in `attached` mode by default
  you will see not output. `-d` for running in detached mode.

### Start and Stop Docker conatainer

```
docker start <container name/container ID>
docker stop <container name/container ID>
```

- Run commands created new container if you just want to start old container you can use `start` command.

- Container is started in `detached` mode by default
  you will see not output. `-a` for running in detached mode.

### Run command on running container

```
docker exec <container name/container ID> <command>
docker exec modest_davinci ls
```

`-it` opens command line in iteractive tty (connects your terminal with container terminal)

```
docker exec -it <container name/container ID> bash
docker exec -it wizardly_chatterjee bash
```

### Removing container and images

can remove stopped containers only

```
docker rm <containe name/ID>
docker rmi <image name/ID>
```

### Remove all containers and images

```
docker container prune
docker image prune -a
```

you can remove images only if they are not being used by any active container.

`docker image prune` removed all dangling images (untagged showind `<none>` as name)

`docker image prune -a` removes unused images also which are not used in any running container.

### Get info about container and image

```
docker container inspect <container id/name>
docker image inspect <image id/name>
```

### Copy file into and outside container

```
docker cp test/. contianer_name:/text
docker cp contianer_name:/text/text.txt text/.
```

## Port Mapping

### Run nginx

```
docker run -p 8080:80 nginx
docker run -it -p 8080:80 nginx
```

`-p <host machine port>:<container port>`

## Environment Variables

```
docker run -it <image id> -e key=value

docker run -it -e key=value key1=value1 ubuntu
docker run -it -e key=value -e key1=value1 ubuntu
```

`-e` flag for environment variables

## Docker Networking

`bridge`: connect to host machine for internet only. differnet network stack than host.

`host`: connected to host machine same port as host machine. same network stack as host.

means if you run some service on container at 8080 port.
if networking is `bridge` you can't access that service on 8080 port of your host machine.
but if networking is `host` you can acccess that service on 8080 port your host machine, as they have same network stack.

### See list of networks

```
docker network ls
```

### See which container are using that network

```
docker network inspect <network ID/name>
```

### Run container whith network specified

```
docker run -it --network host busybox
docker run -it --network=host busybox
docker run -it --network none busybox
docker run -it -d --network host busybox
```

### Creating network

```
docker network create -d bridge anujsd
```

## Docker Volumes

We have different types of data

- Application data: code + environment variables
  - these data is read only and stored in images
- Temporary App data: e.g. files generated by application, user inputs
  - read + write but temporary so will be stored in containers
- Permanent App Data: e.g. user accounts
  - read + write permanent, stored with container and volumns

```
docker run -it -v C:\Users\admin\Desktop\notes\devops\devops\docker\docker-node:/home/anuj ubuntu
```

### Volume and Bind Mounts

#### Anonymous Volume

- Are attached to container they can used to save temporary data
- they do survive container shutdown/restart if container is started without --rm flag
- they do not survice container removal

```
docker run -v /app/data node-asd

docker run -it -p 4000:8081 -v %cd%:/app/ -v /app/node_modules  node-asd
```

#### Named Volume

- they survive container removal so can be used to store persistent data
- they survive container restart/shutdown/removal
- but you can't access them on your host machine they are stored in some obscure location

```
docker run -v data:/app/data node-asd

docker run -it -p 4000:8081 -v %cd%:/app/ -v tmp:/app/node_modules  node-asd
```

#### Bind Mount

- these maps folder on host machine to containers so you can use them like named volumes
- you can store your code on bind mount and then no need to build images again and again
- they survive container restart/shutdown/removal
- and yes you can access them as you are giving location to mount

```
docker run -v "C:/asd":/app/data node-asd

docker run -it -p 4000:8081 -v %cd%:/app/ node-asd
```

## Docker Multi Stage Builds

You can keep build stage and run stage differnet

## Dockerfile

For creating docker images

### Example Docker File

[Dockerizing MERN Bookstore App](https://github.com/Anujsd/MERN-Todo-App/blob/main/frontend/Dockerfile)

```
FROM node

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 5173

ENTRYPOINT [ "npm","run","dev"]
```

### Tagging

```
docker build -t <tag you want to add> <path of Dockerfile>
docker build -t docker-node-asd .
```

`-t` you can give name:tag combination also

### Running my built image

```
docker run -it -e PORT=4000 -p 4000:4000 docker-node-asd
```

### Making efficient images

- make as less layers as possible (less number of lines)

- make them logically sound.

  because if you change any line on layer 3 all layer below will be formed again and you will loose caching benefit.

### RUN vs CMD vs ENTRYPOINT

`RUN` : Image building step. you can have as many RUN as needed.

`CMD` : Container executes it by deafult when you launch the built image. Dockerfile will only use the final CMD defined.

`ENTRYPOINT` : Same work as `CMD`. learn more [here](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact)

## Docker Compose

For Running multiple containers

### Example of compose file

[Dockerizing MERN Bookstore App](https://github.com/Anujsd/MERN-Todo-App)

```
version: '3.8'
services:
  mongodb:
    image: 'mongo'
    ports:
      - '27017:27017'
    volumes:
      - data:/data/db
    env_file:
      - ./.env/mongo.env

  backend:
    build: ./backend
    ports:
      - '4040:4040'
    env_file:
      - ./.env/backend.env
    depends_on:
      - mongodb

  frontend:
    build: ./frontend
    ports:
      - '8000:8000'
    stdin_open: true
    tty: true
    depends_on:
      - backend

volumes:
  data:
```

### Run compose to create and start containers

```
docker compose up
docker compose up -d
```

`-d` for running in detach mode (run in background)

if images are already build it will not build them so use `--build` tag to build latest images

```
docker compose up --build
```

you can run specific service also

```
docker compose run <service name>
```

### Remove containers

```
docker compose down
```

## Concepts
